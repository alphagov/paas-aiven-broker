// Code generated by counterfeiter. DO NOT EDIT.
package fakes

import (
	"sync"

	"github.com/alphagov/paas-aiven-broker/provider/aiven"
)

type FakeClient struct {
	CreateServiceStub        func(*aiven.CreateServiceInput) (string, error)
	createServiceMutex       sync.RWMutex
	createServiceArgsForCall []struct {
		arg1 *aiven.CreateServiceInput
	}
	createServiceReturns struct {
		result1 string
		result2 error
	}
	createServiceReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	CreateServiceUserStub        func(*aiven.CreateServiceUserInput) (string, error)
	createServiceUserMutex       sync.RWMutex
	createServiceUserArgsForCall []struct {
		arg1 *aiven.CreateServiceUserInput
	}
	createServiceUserReturns struct {
		result1 string
		result2 error
	}
	createServiceUserReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	DeleteServiceStub        func(*aiven.DeleteServiceInput) error
	deleteServiceMutex       sync.RWMutex
	deleteServiceArgsForCall []struct {
		arg1 *aiven.DeleteServiceInput
	}
	deleteServiceReturns struct {
		result1 error
	}
	deleteServiceReturnsOnCall map[int]struct {
		result1 error
	}
	DeleteServiceUserStub        func(*aiven.DeleteServiceUserInput) (string, error)
	deleteServiceUserMutex       sync.RWMutex
	deleteServiceUserArgsForCall []struct {
		arg1 *aiven.DeleteServiceUserInput
	}
	deleteServiceUserReturns struct {
		result1 string
		result2 error
	}
	deleteServiceUserReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	ForkServiceStub        func(*aiven.ForkServiceInput) (string, error)
	forkServiceMutex       sync.RWMutex
	forkServiceArgsForCall []struct {
		arg1 *aiven.ForkServiceInput
	}
	forkServiceReturns struct {
		result1 string
		result2 error
	}
	forkServiceReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	GetServiceStub        func(*aiven.GetServiceInput) (*aiven.Service, error)
	getServiceMutex       sync.RWMutex
	getServiceArgsForCall []struct {
		arg1 *aiven.GetServiceInput
	}
	getServiceReturns struct {
		result1 *aiven.Service
		result2 error
	}
	getServiceReturnsOnCall map[int]struct {
		result1 *aiven.Service
		result2 error
	}
	GetServiceTagsStub        func(*aiven.GetServiceTagsInput) (*aiven.ServiceTags, error)
	getServiceTagsMutex       sync.RWMutex
	getServiceTagsArgsForCall []struct {
		arg1 *aiven.GetServiceTagsInput
	}
	getServiceTagsReturns struct {
		result1 *aiven.ServiceTags
		result2 error
	}
	getServiceTagsReturnsOnCall map[int]struct {
		result1 *aiven.ServiceTags
		result2 error
	}
	UpdateServiceStub        func(*aiven.UpdateServiceInput) (string, error)
	updateServiceMutex       sync.RWMutex
	updateServiceArgsForCall []struct {
		arg1 *aiven.UpdateServiceInput
	}
	updateServiceReturns struct {
		result1 string
		result2 error
	}
	updateServiceReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	UpdateServiceTagsStub        func(*aiven.UpdateServiceTagsInput) (string, error)
	updateServiceTagsMutex       sync.RWMutex
	updateServiceTagsArgsForCall []struct {
		arg1 *aiven.UpdateServiceTagsInput
	}
	updateServiceTagsReturns struct {
		result1 string
		result2 error
	}
	updateServiceTagsReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeClient) CreateService(arg1 *aiven.CreateServiceInput) (string, error) {
	fake.createServiceMutex.Lock()
	ret, specificReturn := fake.createServiceReturnsOnCall[len(fake.createServiceArgsForCall)]
	fake.createServiceArgsForCall = append(fake.createServiceArgsForCall, struct {
		arg1 *aiven.CreateServiceInput
	}{arg1})
	stub := fake.CreateServiceStub
	fakeReturns := fake.createServiceReturns
	fake.recordInvocation("CreateService", []interface{}{arg1})
	fake.createServiceMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) CreateServiceCallCount() int {
	fake.createServiceMutex.RLock()
	defer fake.createServiceMutex.RUnlock()
	return len(fake.createServiceArgsForCall)
}

func (fake *FakeClient) CreateServiceCalls(stub func(*aiven.CreateServiceInput) (string, error)) {
	fake.createServiceMutex.Lock()
	defer fake.createServiceMutex.Unlock()
	fake.CreateServiceStub = stub
}

func (fake *FakeClient) CreateServiceArgsForCall(i int) *aiven.CreateServiceInput {
	fake.createServiceMutex.RLock()
	defer fake.createServiceMutex.RUnlock()
	argsForCall := fake.createServiceArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) CreateServiceReturns(result1 string, result2 error) {
	fake.createServiceMutex.Lock()
	defer fake.createServiceMutex.Unlock()
	fake.CreateServiceStub = nil
	fake.createServiceReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) CreateServiceReturnsOnCall(i int, result1 string, result2 error) {
	fake.createServiceMutex.Lock()
	defer fake.createServiceMutex.Unlock()
	fake.CreateServiceStub = nil
	if fake.createServiceReturnsOnCall == nil {
		fake.createServiceReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.createServiceReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) CreateServiceUser(arg1 *aiven.CreateServiceUserInput) (string, error) {
	fake.createServiceUserMutex.Lock()
	ret, specificReturn := fake.createServiceUserReturnsOnCall[len(fake.createServiceUserArgsForCall)]
	fake.createServiceUserArgsForCall = append(fake.createServiceUserArgsForCall, struct {
		arg1 *aiven.CreateServiceUserInput
	}{arg1})
	stub := fake.CreateServiceUserStub
	fakeReturns := fake.createServiceUserReturns
	fake.recordInvocation("CreateServiceUser", []interface{}{arg1})
	fake.createServiceUserMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) CreateServiceUserCallCount() int {
	fake.createServiceUserMutex.RLock()
	defer fake.createServiceUserMutex.RUnlock()
	return len(fake.createServiceUserArgsForCall)
}

func (fake *FakeClient) CreateServiceUserCalls(stub func(*aiven.CreateServiceUserInput) (string, error)) {
	fake.createServiceUserMutex.Lock()
	defer fake.createServiceUserMutex.Unlock()
	fake.CreateServiceUserStub = stub
}

func (fake *FakeClient) CreateServiceUserArgsForCall(i int) *aiven.CreateServiceUserInput {
	fake.createServiceUserMutex.RLock()
	defer fake.createServiceUserMutex.RUnlock()
	argsForCall := fake.createServiceUserArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) CreateServiceUserReturns(result1 string, result2 error) {
	fake.createServiceUserMutex.Lock()
	defer fake.createServiceUserMutex.Unlock()
	fake.CreateServiceUserStub = nil
	fake.createServiceUserReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) CreateServiceUserReturnsOnCall(i int, result1 string, result2 error) {
	fake.createServiceUserMutex.Lock()
	defer fake.createServiceUserMutex.Unlock()
	fake.CreateServiceUserStub = nil
	if fake.createServiceUserReturnsOnCall == nil {
		fake.createServiceUserReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.createServiceUserReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) DeleteService(arg1 *aiven.DeleteServiceInput) error {
	fake.deleteServiceMutex.Lock()
	ret, specificReturn := fake.deleteServiceReturnsOnCall[len(fake.deleteServiceArgsForCall)]
	fake.deleteServiceArgsForCall = append(fake.deleteServiceArgsForCall, struct {
		arg1 *aiven.DeleteServiceInput
	}{arg1})
	stub := fake.DeleteServiceStub
	fakeReturns := fake.deleteServiceReturns
	fake.recordInvocation("DeleteService", []interface{}{arg1})
	fake.deleteServiceMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) DeleteServiceCallCount() int {
	fake.deleteServiceMutex.RLock()
	defer fake.deleteServiceMutex.RUnlock()
	return len(fake.deleteServiceArgsForCall)
}

func (fake *FakeClient) DeleteServiceCalls(stub func(*aiven.DeleteServiceInput) error) {
	fake.deleteServiceMutex.Lock()
	defer fake.deleteServiceMutex.Unlock()
	fake.DeleteServiceStub = stub
}

func (fake *FakeClient) DeleteServiceArgsForCall(i int) *aiven.DeleteServiceInput {
	fake.deleteServiceMutex.RLock()
	defer fake.deleteServiceMutex.RUnlock()
	argsForCall := fake.deleteServiceArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) DeleteServiceReturns(result1 error) {
	fake.deleteServiceMutex.Lock()
	defer fake.deleteServiceMutex.Unlock()
	fake.DeleteServiceStub = nil
	fake.deleteServiceReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) DeleteServiceReturnsOnCall(i int, result1 error) {
	fake.deleteServiceMutex.Lock()
	defer fake.deleteServiceMutex.Unlock()
	fake.DeleteServiceStub = nil
	if fake.deleteServiceReturnsOnCall == nil {
		fake.deleteServiceReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteServiceReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) DeleteServiceUser(arg1 *aiven.DeleteServiceUserInput) (string, error) {
	fake.deleteServiceUserMutex.Lock()
	ret, specificReturn := fake.deleteServiceUserReturnsOnCall[len(fake.deleteServiceUserArgsForCall)]
	fake.deleteServiceUserArgsForCall = append(fake.deleteServiceUserArgsForCall, struct {
		arg1 *aiven.DeleteServiceUserInput
	}{arg1})
	stub := fake.DeleteServiceUserStub
	fakeReturns := fake.deleteServiceUserReturns
	fake.recordInvocation("DeleteServiceUser", []interface{}{arg1})
	fake.deleteServiceUserMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) DeleteServiceUserCallCount() int {
	fake.deleteServiceUserMutex.RLock()
	defer fake.deleteServiceUserMutex.RUnlock()
	return len(fake.deleteServiceUserArgsForCall)
}

func (fake *FakeClient) DeleteServiceUserCalls(stub func(*aiven.DeleteServiceUserInput) (string, error)) {
	fake.deleteServiceUserMutex.Lock()
	defer fake.deleteServiceUserMutex.Unlock()
	fake.DeleteServiceUserStub = stub
}

func (fake *FakeClient) DeleteServiceUserArgsForCall(i int) *aiven.DeleteServiceUserInput {
	fake.deleteServiceUserMutex.RLock()
	defer fake.deleteServiceUserMutex.RUnlock()
	argsForCall := fake.deleteServiceUserArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) DeleteServiceUserReturns(result1 string, result2 error) {
	fake.deleteServiceUserMutex.Lock()
	defer fake.deleteServiceUserMutex.Unlock()
	fake.DeleteServiceUserStub = nil
	fake.deleteServiceUserReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) DeleteServiceUserReturnsOnCall(i int, result1 string, result2 error) {
	fake.deleteServiceUserMutex.Lock()
	defer fake.deleteServiceUserMutex.Unlock()
	fake.DeleteServiceUserStub = nil
	if fake.deleteServiceUserReturnsOnCall == nil {
		fake.deleteServiceUserReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.deleteServiceUserReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) ForkService(arg1 *aiven.ForkServiceInput) (string, error) {
	fake.forkServiceMutex.Lock()
	ret, specificReturn := fake.forkServiceReturnsOnCall[len(fake.forkServiceArgsForCall)]
	fake.forkServiceArgsForCall = append(fake.forkServiceArgsForCall, struct {
		arg1 *aiven.ForkServiceInput
	}{arg1})
	stub := fake.ForkServiceStub
	fakeReturns := fake.forkServiceReturns
	fake.recordInvocation("ForkService", []interface{}{arg1})
	fake.forkServiceMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) ForkServiceCallCount() int {
	fake.forkServiceMutex.RLock()
	defer fake.forkServiceMutex.RUnlock()
	return len(fake.forkServiceArgsForCall)
}

func (fake *FakeClient) ForkServiceCalls(stub func(*aiven.ForkServiceInput) (string, error)) {
	fake.forkServiceMutex.Lock()
	defer fake.forkServiceMutex.Unlock()
	fake.ForkServiceStub = stub
}

func (fake *FakeClient) ForkServiceArgsForCall(i int) *aiven.ForkServiceInput {
	fake.forkServiceMutex.RLock()
	defer fake.forkServiceMutex.RUnlock()
	argsForCall := fake.forkServiceArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) ForkServiceReturns(result1 string, result2 error) {
	fake.forkServiceMutex.Lock()
	defer fake.forkServiceMutex.Unlock()
	fake.ForkServiceStub = nil
	fake.forkServiceReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) ForkServiceReturnsOnCall(i int, result1 string, result2 error) {
	fake.forkServiceMutex.Lock()
	defer fake.forkServiceMutex.Unlock()
	fake.ForkServiceStub = nil
	if fake.forkServiceReturnsOnCall == nil {
		fake.forkServiceReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.forkServiceReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) GetService(arg1 *aiven.GetServiceInput) (*aiven.Service, error) {
	fake.getServiceMutex.Lock()
	ret, specificReturn := fake.getServiceReturnsOnCall[len(fake.getServiceArgsForCall)]
	fake.getServiceArgsForCall = append(fake.getServiceArgsForCall, struct {
		arg1 *aiven.GetServiceInput
	}{arg1})
	stub := fake.GetServiceStub
	fakeReturns := fake.getServiceReturns
	fake.recordInvocation("GetService", []interface{}{arg1})
	fake.getServiceMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) GetServiceCallCount() int {
	fake.getServiceMutex.RLock()
	defer fake.getServiceMutex.RUnlock()
	return len(fake.getServiceArgsForCall)
}

func (fake *FakeClient) GetServiceCalls(stub func(*aiven.GetServiceInput) (*aiven.Service, error)) {
	fake.getServiceMutex.Lock()
	defer fake.getServiceMutex.Unlock()
	fake.GetServiceStub = stub
}

func (fake *FakeClient) GetServiceArgsForCall(i int) *aiven.GetServiceInput {
	fake.getServiceMutex.RLock()
	defer fake.getServiceMutex.RUnlock()
	argsForCall := fake.getServiceArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) GetServiceReturns(result1 *aiven.Service, result2 error) {
	fake.getServiceMutex.Lock()
	defer fake.getServiceMutex.Unlock()
	fake.GetServiceStub = nil
	fake.getServiceReturns = struct {
		result1 *aiven.Service
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) GetServiceReturnsOnCall(i int, result1 *aiven.Service, result2 error) {
	fake.getServiceMutex.Lock()
	defer fake.getServiceMutex.Unlock()
	fake.GetServiceStub = nil
	if fake.getServiceReturnsOnCall == nil {
		fake.getServiceReturnsOnCall = make(map[int]struct {
			result1 *aiven.Service
			result2 error
		})
	}
	fake.getServiceReturnsOnCall[i] = struct {
		result1 *aiven.Service
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) GetServiceTags(arg1 *aiven.GetServiceTagsInput) (*aiven.ServiceTags, error) {
	fake.getServiceTagsMutex.Lock()
	ret, specificReturn := fake.getServiceTagsReturnsOnCall[len(fake.getServiceTagsArgsForCall)]
	fake.getServiceTagsArgsForCall = append(fake.getServiceTagsArgsForCall, struct {
		arg1 *aiven.GetServiceTagsInput
	}{arg1})
	stub := fake.GetServiceTagsStub
	fakeReturns := fake.getServiceTagsReturns
	fake.recordInvocation("GetServiceTags", []interface{}{arg1})
	fake.getServiceTagsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) GetServiceTagsCallCount() int {
	fake.getServiceTagsMutex.RLock()
	defer fake.getServiceTagsMutex.RUnlock()
	return len(fake.getServiceTagsArgsForCall)
}

func (fake *FakeClient) GetServiceTagsCalls(stub func(*aiven.GetServiceTagsInput) (*aiven.ServiceTags, error)) {
	fake.getServiceTagsMutex.Lock()
	defer fake.getServiceTagsMutex.Unlock()
	fake.GetServiceTagsStub = stub
}

func (fake *FakeClient) GetServiceTagsArgsForCall(i int) *aiven.GetServiceTagsInput {
	fake.getServiceTagsMutex.RLock()
	defer fake.getServiceTagsMutex.RUnlock()
	argsForCall := fake.getServiceTagsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) GetServiceTagsReturns(result1 *aiven.ServiceTags, result2 error) {
	fake.getServiceTagsMutex.Lock()
	defer fake.getServiceTagsMutex.Unlock()
	fake.GetServiceTagsStub = nil
	fake.getServiceTagsReturns = struct {
		result1 *aiven.ServiceTags
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) GetServiceTagsReturnsOnCall(i int, result1 *aiven.ServiceTags, result2 error) {
	fake.getServiceTagsMutex.Lock()
	defer fake.getServiceTagsMutex.Unlock()
	fake.GetServiceTagsStub = nil
	if fake.getServiceTagsReturnsOnCall == nil {
		fake.getServiceTagsReturnsOnCall = make(map[int]struct {
			result1 *aiven.ServiceTags
			result2 error
		})
	}
	fake.getServiceTagsReturnsOnCall[i] = struct {
		result1 *aiven.ServiceTags
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) UpdateService(arg1 *aiven.UpdateServiceInput) (string, error) {
	fake.updateServiceMutex.Lock()
	ret, specificReturn := fake.updateServiceReturnsOnCall[len(fake.updateServiceArgsForCall)]
	fake.updateServiceArgsForCall = append(fake.updateServiceArgsForCall, struct {
		arg1 *aiven.UpdateServiceInput
	}{arg1})
	stub := fake.UpdateServiceStub
	fakeReturns := fake.updateServiceReturns
	fake.recordInvocation("UpdateService", []interface{}{arg1})
	fake.updateServiceMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) UpdateServiceCallCount() int {
	fake.updateServiceMutex.RLock()
	defer fake.updateServiceMutex.RUnlock()
	return len(fake.updateServiceArgsForCall)
}

func (fake *FakeClient) UpdateServiceCalls(stub func(*aiven.UpdateServiceInput) (string, error)) {
	fake.updateServiceMutex.Lock()
	defer fake.updateServiceMutex.Unlock()
	fake.UpdateServiceStub = stub
}

func (fake *FakeClient) UpdateServiceArgsForCall(i int) *aiven.UpdateServiceInput {
	fake.updateServiceMutex.RLock()
	defer fake.updateServiceMutex.RUnlock()
	argsForCall := fake.updateServiceArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) UpdateServiceReturns(result1 string, result2 error) {
	fake.updateServiceMutex.Lock()
	defer fake.updateServiceMutex.Unlock()
	fake.UpdateServiceStub = nil
	fake.updateServiceReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) UpdateServiceReturnsOnCall(i int, result1 string, result2 error) {
	fake.updateServiceMutex.Lock()
	defer fake.updateServiceMutex.Unlock()
	fake.UpdateServiceStub = nil
	if fake.updateServiceReturnsOnCall == nil {
		fake.updateServiceReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.updateServiceReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) UpdateServiceTags(arg1 *aiven.UpdateServiceTagsInput) (string, error) {
	fake.updateServiceTagsMutex.Lock()
	ret, specificReturn := fake.updateServiceTagsReturnsOnCall[len(fake.updateServiceTagsArgsForCall)]
	fake.updateServiceTagsArgsForCall = append(fake.updateServiceTagsArgsForCall, struct {
		arg1 *aiven.UpdateServiceTagsInput
	}{arg1})
	stub := fake.UpdateServiceTagsStub
	fakeReturns := fake.updateServiceTagsReturns
	fake.recordInvocation("UpdateServiceTags", []interface{}{arg1})
	fake.updateServiceTagsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) UpdateServiceTagsCallCount() int {
	fake.updateServiceTagsMutex.RLock()
	defer fake.updateServiceTagsMutex.RUnlock()
	return len(fake.updateServiceTagsArgsForCall)
}

func (fake *FakeClient) UpdateServiceTagsCalls(stub func(*aiven.UpdateServiceTagsInput) (string, error)) {
	fake.updateServiceTagsMutex.Lock()
	defer fake.updateServiceTagsMutex.Unlock()
	fake.UpdateServiceTagsStub = stub
}

func (fake *FakeClient) UpdateServiceTagsArgsForCall(i int) *aiven.UpdateServiceTagsInput {
	fake.updateServiceTagsMutex.RLock()
	defer fake.updateServiceTagsMutex.RUnlock()
	argsForCall := fake.updateServiceTagsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) UpdateServiceTagsReturns(result1 string, result2 error) {
	fake.updateServiceTagsMutex.Lock()
	defer fake.updateServiceTagsMutex.Unlock()
	fake.UpdateServiceTagsStub = nil
	fake.updateServiceTagsReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) UpdateServiceTagsReturnsOnCall(i int, result1 string, result2 error) {
	fake.updateServiceTagsMutex.Lock()
	defer fake.updateServiceTagsMutex.Unlock()
	fake.UpdateServiceTagsStub = nil
	if fake.updateServiceTagsReturnsOnCall == nil {
		fake.updateServiceTagsReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.updateServiceTagsReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.createServiceMutex.RLock()
	defer fake.createServiceMutex.RUnlock()
	fake.createServiceUserMutex.RLock()
	defer fake.createServiceUserMutex.RUnlock()
	fake.deleteServiceMutex.RLock()
	defer fake.deleteServiceMutex.RUnlock()
	fake.deleteServiceUserMutex.RLock()
	defer fake.deleteServiceUserMutex.RUnlock()
	fake.forkServiceMutex.RLock()
	defer fake.forkServiceMutex.RUnlock()
	fake.getServiceMutex.RLock()
	defer fake.getServiceMutex.RUnlock()
	fake.getServiceTagsMutex.RLock()
	defer fake.getServiceTagsMutex.RUnlock()
	fake.updateServiceMutex.RLock()
	defer fake.updateServiceMutex.RUnlock()
	fake.updateServiceTagsMutex.RLock()
	defer fake.updateServiceTagsMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeClient) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ aiven.Client = new(FakeClient)
